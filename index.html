<!DOCTYPE html>
<html lang="ru">
<head>
  <!-- Остальные мета-теги и стили остаются без изменений -->
</head>
<body>
  <!-- HTML-структура остается без изменений -->

  <script>
    document.addEventListener("DOMContentLoaded", async () => {
      // Проверка загрузки TensorFlow.js
      if (!window.tf) {
        showError("TensorFlow.js не загружен. Пожалуйста, обновите страницу.");
        return;
      }

      // Остальные константы и переменные
      
      // Основные исправления:

      // 1. Оптимизированная функция создания модели
      const createModel = () => {
        try {
          const model = tf.sequential();
          model.add(tf.layers.dense({ 
            inputShape: [10], 
            units: 32,  // Уменьшено количество нейронов
            activation: 'relu',
            kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })
          }));
          model.add(tf.layers.dropout({ rate: 0.2 }));  // Уменьшен dropout
          model.add(tf.layers.dense({ units: 16, activation: 'relu' })); // Упрощена архитектура
          model.add(tf.layers.dense({ units: 1, activation: 'sigmoid' }));
          
          model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
          });
          
          return model;
        } catch (error) {
          console.error("Ошибка создания модели:", error);
          return null;
        }
      };

      // 2. Оптимизированная генерация данных
      const generateTrainingData = (samples = 200) => {  // Уменьшено количество образцов
        try {
          const xs = [];
          const ys = [];
          
          const patterns = [
            { start: 1.5, trend: -0.02, noise: 0.05, label: 1 },
            { start: 2.5, trend: 0.03, noise: 0.08, label: 0 },
            { start: 1.9, trend: 0.0, noise: 0.1, label: 0.5 }
          ];

          for (let i = 0; i < samples; i++) {
            const pattern = patterns[i % patterns.length];
            const game = Array.from({ length: 10 }, (_, j) => {
              const baseValue = pattern.start + (j * pattern.trend);
              const noise = (Math.random() * 2 - 1) * pattern.noise;
              return Math.min(5.0, Math.max(1.0, parseFloat((baseValue + noise).toFixed(2)));
            });
            
            xs.push(game);
            ys.push(pattern.label);
          }

          return {
            xs: tf.tensor2d(xs),
            ys: tf.tensor1d(ys)
          };
        } catch (error) {
          console.error("Ошибка генерации данных:", error);
          return null;
        }
      };

      // 3. Оптимизированное обучение модели
      const initModel = async () => {
        showLoader();
        try {
          const newModel = createModel();
          if (!newModel) throw new Error("Не удалось создать модель");
          
          const trainingData = generateTrainingData();
          if (!trainingData) throw new Error("Не удалось сгенерировать данные");
          
          // Уменьшено количество эпох и добавлена проверка на прерывание
          let stopTraining = false;
          const stopBtn = document.createElement("button");
          stopBtn.textContent = "Прервать обучение";
          stopBtn.style.marginTop = "10px";
          stopBtn.onclick = () => { stopTraining = true; };
          loader.appendChild(stopBtn);

          await newModel.fit(trainingData.xs, trainingData.ys, {
            epochs: 30,  // Уменьшено количество эпох
            batchSize: 16,
            validationSplit: 0.2,
            callbacks: {
              onEpochEnd: (epoch, logs) => {
                if ((epoch + 1) % 5 === 0) {
                  console.log(`Эпоха ${epoch + 1}: Ошибка = ${logs.loss.toFixed(4)}`);
                }
                if (stopTraining) {
                  newModel.stopTraining = true;
                  console.log("Обучение прервано пользователем");
                }
              }
            }
          });
          
          // Очищаем тензоры
          tf.dispose([trainingData.xs, trainingData.ys]);
          loader.removeChild(stopBtn);
          
          return newModel;
        } catch (error) {
          console.error("Ошибка инициализации модели:", error);
          showError("Ошибка при создании модели. Пожалуйста, обновите страницу.");
          return null;
        } finally {
          hideLoader();
        }
      };

      // 4. Оптимизированное предсказание
      const predictWinner = async () => {
        if (!model || !isModelReady) {
          showError("Модель не готова. Пожалуйста, подождите...");
          return;
        }

        showLoader();
        hideError();
        try {
          // Быстрый сбор данных без сложных операций
          const inputs = Array.from(document.querySelectorAll('input[type="text"]'));
          const playerA = [];
          const playerB = [];
          
          inputs.forEach(input => {
            const value = parseFloat(input.value);
            if (!isNaN(value) && value >= 1.0 && value <= 5.0) {
              input.dataset.player === 'a' ? playerA.push(value) : playerB.push(value);
            }
          });

          if (playerA.length === 0 || playerB.length === 0) {
            showError("Введите коэффициенты для обоих игроков!");
            return;
          }

          // Оптимизированные вычисления
          const processedA = normalizeCoefficients(padArray(playerA, 10));
          const processedB = normalizeCoefficients(padArray(playerB, 10));
          
          // Быстрое предсказание с контролем памяти
          const tensorA = tf.tensor2d([processedA]);
          const tensorB = tf.tensor2d([processedB]);
          
          const [predictionA, predictionB] = await Promise.all([
            model.predict(tensorA).data(),
            model.predict(tensorB).data()
          ]);
          
          const probA = (predictionA[0] * 100).toFixed(1);
          const probB = (predictionB[0] * 100).toFixed(1);
          
          // Немедленная очистка памяти
          tf.dispose([tensorA, tensorB]);
          
          displayResults(probA, probB, playerA, playerB);
          
        } catch (error) {
          console.error("Ошибка прогнозирования:", error);
          showError("Ошибка при анализе данных. Проверьте введенные значения.");
        } finally {
          hideLoader();
        }
      };

      // Остальной код остается без изменений
      
      // Инициализация приложения с обработкой ошибок
      const initApp = async () => {
        showLoader();
        try {
          model = await initModel();
          if (model) {
            isModelReady = true;
            validateInputs();
            console.log("Модель успешно загружена и готова к использованию");
          } else {
            showError("Не удалось инициализировать модель");
          }
        } catch (error) {
          console.error("Ошибка инициализации приложения:", error);
          showError("Ошибка инициализации. Пожалуйста, обновите страницу.");
        } finally {
          hideLoader();
        }
      };

      // Запускаем инициализацию
      initApp();
    });
  </script>
</body>
</html>
